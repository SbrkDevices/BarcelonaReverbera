import sys
import os
import soundfile as sf

CONVOLUTION_REVERB_LARGEST_STAGE_SAMPLES = 16 * 1024

FS = 48000
WAV_MIN_LENGTH_SAMPLES = 3 * CONVOLUTION_REVERB_LARGEST_STAGE_SAMPLES
WAV_MAX_LENGTH_SAMPLES = 10 * FS

NUM_EXTRA_ZEROS = CONVOLUTION_REVERB_LARGEST_STAGE_SAMPLES

def getSignalName(wavFile):
    wavFileSplitSlashes = wavFile.split('/')
    return wavFileSplitSlashes[len(wavFileSplitSlashes)-1].split('.')[0]

# Check the input arguments
if len(sys.argv) < 2:
    print("Usage: python3 convert_wav_to_c_array.py <audio_file1.wav> <audio_file2.wav> ...")
    sys.exit(1)

numFiles = 0
for wavFile in sys.argv[1:]:
    if wavFile.endswith('.wav'):
        numFiles += 1

# Open the header file for writing
scriptDir = os.path.dirname(os.path.abspath(__file__))
headerPath = os.path.join(scriptDir, 'IrBuffersAutoGenerated.h')

# Initialize the IrBuffers class in the header file
with open(headerPath, 'w') as headerFile:
    headerFile.write('#pragma once\n\n')
    headerFile.write('// CAUTION: THIS FILE IS AUTO-GENERATED WITH THE ConvertWavsToCArray.py TOOL, DO NOT EDIT MANUALLY!\n\n')
    headerFile.write('class IrBuffers\n{\n')
    headerFile.write('private:\n')
    headerFile.write(f'    static constexpr int m_irCount = {numFiles};\n')
    headerFile.write(f'    static constexpr int m_irBuffersExtraZeros = {NUM_EXTRA_ZEROS};\n\n')

    fileIndex = 0

    # Process each audio file
    for wavFile in sys.argv[1:]:
        if not wavFile.endswith('.wav'):
            print(f"INFO: Skipping non-wav file: {wavFile}")
            continue

        data, fs = sf.read(wavFile)
        audioLen = len(data)

        if fs != FS:
            print(f"ERROR: {wavFile} sample rate is not {FS} Hz")
            sys.exit(1)

        if audioLen < WAV_MIN_LENGTH_SAMPLES or audioLen > WAV_MAX_LENGTH_SAMPLES:
            print(f"ERROR: {wavFile} does not meet length requirements")
            sys.exit(1)
        
        if (len(data[0]) != 2):
            print("ERROR: Source audio file should be stereo (2 channels)")
            sys.exit(1)
        
        #trim final zeros...
        trimCount = 0
        for i in range(0, audioLen):
            index = (audioLen - 1) - i
            if ((data[index][0] == 0) and (data[index][1] == 0)):
                trimCount += 1
            else:
                break

        audioLen -= trimCount
        audioPlusZerosLen = audioLen + NUM_EXTRA_ZEROS

        headerFile.write(f'    float m_audioBuffer_{fileIndex}[2][{audioPlusZerosLen}] =\n')
        headerFile.write('    {\n')

        for ch in range(0, 2):
            headerFile.write('        {\n            ')

            for i in range(0, audioPlusZerosLen):
                if (i < audioLen):
                    headerFile.write(f'{data[i][ch]}, ')
                else:
                    headerFile.write('0.0, ')

            headerFile.write('\n        },\n')

        headerFile.write('    };\n\n')

        fileIndex += 1

    headerFile.write('    const char m_irNames[m_irCount][128] =\n    {\n')

    # Add audio file names:
    for wavFile in sys.argv[1:]:
        if not wavFile.endswith('.wav'):
            continue
    
        signalName = getSignalName(wavFile)
        headerFile.write(f'        "{signalName}",\n')

    headerFile.write('    };\n\n')

    headerFile.write('public:\n')
    headerFile.write('    static constexpr int getIrCount(void)\n    {\n        return m_irCount;\n    }\n\n')
    headerFile.write('    char* getIrName(int irIndex)\n    {\n        if (irIndex >= m_irCount)\n            return nullptr;\n\n        return (char*) m_irNames[irIndex];\n    }\n\n')

    headerFile.write('    float* getIrAudioBuffer(int irIndex, int channel)\n    {\n        if ((irIndex >= m_irCount) || (channel >= 2))\n            return nullptr;\n\n')
    for i in range(0, numFiles):
        headerFile.write(f'        if (irIndex == {i})\n')
        headerFile.write('        {\n')
        headerFile.write(f'            return m_audioBuffer_{i}[channel];\n')
        headerFile.write('        }\n')
    headerFile.write('        \n        return nullptr;\n    }\n')

    headerFile.write('    uint32_t getIrLenWithZeros(int irIndex)\n    {\n        if (irIndex >= m_irCount)\n            return 0;\n\n')
    for i in range(0, numFiles):
        headerFile.write(f'        if (irIndex == {i})\n')
        headerFile.write('        {\n')
        headerFile.write(f'            return sizeof(m_audioBuffer_{i})/(2*sizeof(float));\n')
        headerFile.write('        }\n')
    headerFile.write('        \n        return 0;\n    }\n\n')

    headerFile.write('    uint32_t getIrLen(int irIndex)\n    {\n        return getIrLenWithZeros(irIndex) - m_irBuffersExtraZeros;\n    }\n\n')

    headerFile.write('    static char* getIrImgPtr(int irIndex)\n    {\n        if (irIndex >= m_irCount)\n            return nullptr;\n\n')
    for i in range(0, numFiles):
        headerFile.write(f'        if (irIndex == {i})\n')
        headerFile.write('        {\n')
        headerFile.write(f'            return (char*) BinaryData::IR_img_{i:02d}_jpg;\n')
        headerFile.write('        }\n')
    headerFile.write('        \n        return nullptr;\n    }\n\n')

    headerFile.write('    static uint32_t getIrImgSize(int irIndex)\n    {\n        if (irIndex >= m_irCount)\n            return 0;\n\n')
    for i in range(0, numFiles):
        headerFile.write(f'        if (irIndex == {i})\n')
        headerFile.write('        {\n')
        headerFile.write(f'            return BinaryData::IR_img_{i:02d}_jpgSize;\n')
        headerFile.write('        }\n')
    headerFile.write('        \n        return 0;\n    }\n')

    headerFile.write('};\n')

print('Header file created! Thanks for using sbrk services')