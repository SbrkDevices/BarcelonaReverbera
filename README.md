# Barcelona Reverbera

Non-Uniform Partitioned Convolution Reverb VST3 plugin, developed on C++ using JUCE 8. Used to create the Barcelona Reverbera VST3 plugin.

This convolution reverb was developed as part of the Barcelona Reverbera project, which aims to create a VST plugin where some iconic spaces of Barcelona can be used as convolution reverb impulse responses. The original impulse responses are not uploaded on this repo due to proprietary issues.

https://sbrkdevices.com/barcelona-reverbera

The source code is in src/BarcelonaReverbera. The Non-Uniform Partitioned Convolution implementation is located at src/BarcelonaReverbera/ConvolutionReverb/ConvolutionEngine. It uses modern features of C++ in order to create the different FFT convolution stages using template metaprogramming. The src/BarcelonaReverbera/ConvolutionReverb/Fft/Fft.h file includes a helper class for the forward an inverse FFTs. The pffft (https://bitbucket.org/jpommier/pffft/src) library is used to compute the FFTs.

In src/BarcelonaReverbera/ConvolutionReverb/ConvolutionEngine/ConvolutionEngine.h, in the top of the file, a little scheme is drawn which explains how the different stages process each part of the impulse response in the Non-Uniform Partitioned Convolution implementation. The first 2 stages are done using direct convolution, which allows for 0 samples latency. The next stages are FFT stages with increasing block sizes.

In ConvertWavstoCArray/ConvertWavstoCArray.py, a python script creates C++ header files from impulse responses stored in WAV files (must be stereo, 48 kHz). The generated header file can be replaced at src/BarcelonaReverbera/ConvolutionReverb/ImpulseResponses/IrBuffersAutoGenerated.h to be used for convolution.

Two impulse responses are given as examples in src/BarcelonaReverbera/ConvolutionReverb/ImpulseResponses/IrBuffersAutoGenerated.h: a delta function, and a delta function with a unity delay.

## Build process

First, execute build/get_libraries.sh (or get_libraries.bat on Windows), to get the JUCE 8 and PFFFT libraries. Then, the Projucer project can be opened, located in build/BarcelonaReverbera.jucer. Alternatively, open the desired OS project from build/Builds: MacOSX, LinuxMakefile or VisualStudio2022 for Windows. Compile those in Debug or Release configurations, as desired (in Linux, this is done with "make CONFIG=Debug" or "make CONFIG=Release"). In the Projucer, you can also change some of the optimizations and architecture flags used for Release configuration.

A Visual Studio Code workspace file is also given at build/BarcelonaReverbera.code-workspace. In MacOSX and Windows, this is only used as an editor. In Linux, compiling tasks and debugging configurations have also been added (the AudioPluginHost must be compiled previously, which is in the extras/AudioPluginHost directory of the JUCE folder).

In MacOSX, XCode builds a Universal Binary, which contains executables for both x86 and Apple Silicon (ARM64) architectures.

## Compiler optimizations and architecture

By default, the Projucer activates the -O3 flag in Release configuration to improve the plugin's performance. In the project files for the different OS given in this repository, this hasn't been modified. However, it is possible to activate compiler optimizations and architecture-specific instructions in each OS. This is can be done directly in the OS-specific projects. Particularly, allowing the compilers to use SIMD instructions (such as AVX for x86 and NEON for arm64) is very useful to accelerate floating-point operations. Even if we don't explicitly use SIMD intrinsics, the compiler is clever enough to find places where it can use these vector instructions.

XCode (MAC OSX): In the project settings, under the "Build Settings" tab, display "All" options. Here, many compiler/linker options can be changed for each target (VST3, AU...). I changed "Enable Additional Vector Extensions" to AVX in Release configuration, and "Unroll Loops" to Yes in Release configuration, both for all targets. This will only affect the x86_64 executable section contained in the Universal Binary. I have checked that the binary actually includes AVX instructions, with the following command "otool -arch x86_64 -tv BarcelonaReverbera.vst3/Contents/MacOS/BarcelonaReverbera > disassembly_x86.txt" and then checking that it actually contains AVX instructions such as "vaddps", "vmulps", ... The same check can be done on the Universal Binary for the ARM64 architecture: "otool -arch arm64 -tv BarcelonaReverbera.vst3/Contents/MacOS/BarcelonaReverbera > disassembly_arm64.txt" and then searching for NEON instructions.

Makefile (Linux): For building in release configuration, use 'make CONFIG=Release CFLAGS="-mavx -funroll-loops"' (use your desired vector extension version: SSE2, AVX2...). This has also been added in the build/BarcelonaReverbera.code-workspace file for compiling on Linux.

Visual Studio 2022 (Windows): For each project, open its Properties page, go to the "C/C++" section, and find the option "Enable Enhanced Instruction Set". Choose the desired option, I chose AVX (/arch:AVX).

## License

See LICENSE file.

## Future work

 - Add support for more languages: Spanish, Catalan...
 - Set decay knob in seconds or milliseconds units, and color and dry/wet in percentage units.
 - Improvement of image resolution.
 - Increasing IR library: more IRs of Barcelona and other places. Possibly: support for custom IRs.
 - Thread system: work on the priority scheme and organization of the FFT-block processing threads.
 - Quality improvement: double precission (64-bit) floating point processing.
 - SIMD optimizations.
 - Other optimizations.